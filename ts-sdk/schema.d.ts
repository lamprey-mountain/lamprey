/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
	"/api/v1/auth": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Auth status (TODO) */
		get: operations["auth_status"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/auth/captcha/init": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/** Auth captcha init (TODO) */
		post: operations["auth_captcha_init"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/auth/captcha/submit": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/** Auth captcha submit (TODO) */
		post: operations["auth_captcha_submit"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/auth/email/{addr}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Auth email exec (TODO)
		 * @description Send a "magic link" email to login
		 */
		post: operations["auth_email_exec"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/auth/email/{addr}/reset": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Auth email reset (TODO)
		 * @description Like exec, but the link also resets the password
		 */
		post: operations["auth_email_reset"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/auth/oauth/{provider}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Auth oauth get (TODO) */
		get: operations["auth_oauth_get"];
		put?: never;
		/** Auth oauth init */
		post: operations["auth_oauth_init"];
		/** Auth oauth delete (TODO) */
		delete: operations["auth_oauth_delete"];
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/auth/oauth/{provider}/logout": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/** Auth oauth logout (TODO) */
		post: operations["auth_oauth_logout"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/auth/oauth/{provider}/redirect": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Auth oauth redirect */
		get: operations["auth_oauth_redirect"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/auth/password": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		/** Auth password set (TODO) */
		put: operations["auth_password_set"];
		/** Auth password exec (TODO) */
		post: operations["auth_password_exec"];
		/** Auth password delete (TODO) */
		delete: operations["auth_password_delete"];
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/auth/totp": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/** Auth totp execute (TODO) */
		post: operations["auth_totp_exec"];
		/** Auth totp delete (TODO) */
		delete: operations["auth_totp_delete"];
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/auth/totp/init": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/** Auth totp init (TODO) */
		post: operations["auth_totp_init"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/auth/totp/recovery": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Auth totp recovery codes get (TODO) */
		get: operations["auth_totp_recovery_get"];
		put?: never;
		/** Auth totp recovery codes rotate (TODO) */
		post: operations["auth_totp_recovery_rotate"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/debug/embed-url": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/** Embed a url */
		post: operations["debug_embed_url"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/debug/version": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Get server version */
		get: operations["debug_version"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/emoji": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Emoji create (TODO)
		 * @description Create a custom emoji.
		 */
		post: operations["emoji_create"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/emoji/{emoji_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Emoji get (TODO)
		 * @description Get a custom emoji.
		 */
		get: operations["emoji_get"];
		put?: never;
		post?: never;
		/**
		 * Emoji delete (TODO)
		 * @description Delete a custom emoji.
		 */
		delete: operations["emoji_delete"];
		options?: never;
		head?: never;
		/**
		 * Emoji update (TODO)
		 * @description Edit a custom emoji.
		 */
		patch: operations["emoji_update"];
		trace?: never;
	};
	"/api/v1/inbox": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Inbox list (TODO)
		 * @description List notifications.
		 */
		get: operations["inbox_query"];
		put?: never;
		/**
		 * Inbox edit (TODO)
		 * @description Edit notifications in the inbox.
		 */
		post: operations["inbox_patch"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/invite/{invite_code}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Invite resolve */
		get: operations["invite_resolve"];
		put?: never;
		/** Invite use */
		post: operations["invite_use"];
		/** Invite delete */
		delete: operations["invite_delete"];
		options?: never;
		head?: never;
		/**
		 * Invite patch (TODO)
		 * @description Edit an invite
		 */
		patch: operations["invite_patch"];
		trace?: never;
	};
	"/api/v1/media": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Media create
		 * @description Create a new url to upload media to. Use the media upload endpoint for actually uploading media. Media not referenced/used in other api calls will be removed after a period of time.
		 */
		post: operations["media_create"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/media/{media_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Media get */
		get: operations["media_get"];
		put?: never;
		post?: never;
		/**
		 * Media delete
		 * @description Delete unlinked media. If its linked to a message, delete that message instead.
		 */
		delete: operations["media_delete"];
		options?: never;
		head?: never;
		/** Media patch */
		patch: operations["media_patch"];
		trace?: never;
	};
	"/api/v1/media/{media_id}/done": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		/**
		 * Media done
		 * @description finishes a media upload. at this point, the media becomes immutable
		 */
		put: operations["media_done"];
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/media/{media_id}/report": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Report media (TODO)
		 * @description Report media
		 */
		post: operations["report_media"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/room": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** List visible rooms */
		get: operations["room_list"];
		put?: never;
		/** Create a room */
		post: operations["room_create"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/room/{room_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Get a room by its id */
		get: operations["room_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		/** Edit a room */
		patch: operations["room_edit"];
		trace?: never;
	};
	"/api/v1/room/{room_id}/ack": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		/**
		 * Ack room (TODO)
		 * @description Mark all threads in a room as read.
		 */
		put: operations["room_ack"];
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/room/{room_id}/invite": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Invite room list
		 * @description List invites that go to a room
		 */
		get: operations["invite_room_list"];
		put?: never;
		/**
		 * Invite room create
		 * @description Create an invite that goes to a room
		 */
		post: operations["invite_room_create"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/room/{room_id}/logs": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Fetch audit logs */
		get: operations["room_audit_logs"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/room/{room_id}/member": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Room member list */
		get: operations["room_member_list"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/room/{room_id}/member/{user_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Room member get */
		get: operations["room_member_get"];
		/**
		 * Room member add
		 * @description Only `Puppet` users can be added to rooms (via MemberBridge permission)
		 */
		put: operations["room_member_add"];
		post?: never;
		/** Room member delete (kick/leave) */
		delete: operations["room_member_delete"];
		options?: never;
		head?: never;
		/** Room member update */
		patch: operations["room_member_update"];
		trace?: never;
	};
	"/api/v1/room/{room_id}/notifications": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		/**
		 * Notification edit room (TODO)
		 * @description Edit notification settings for a room.
		 */
		patch: operations["notification_edit_room"];
		trace?: never;
	};
	"/api/v1/room/{room_id}/report": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Report room (TODO)
		 * @description Report a room
		 */
		post: operations["report_room"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/room/{room_id}/role": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Role list */
		get: operations["role_list"];
		put?: never;
		/** Role create */
		post: operations["role_create"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/room/{room_id}/role/{role_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Role get */
		get: operations["role_get"];
		put?: never;
		post?: never;
		/** Role delete */
		delete: operations["role_delete"];
		options?: never;
		head?: never;
		/** Role update */
		patch: operations["role_update"];
		trace?: never;
	};
	"/api/v1/room/{room_id}/role/{role_id}/member": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Role list members */
		get: operations["role_member_list"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/room/{room_id}/role/{role_id}/member/{user_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		/** Role member apply */
		put: operations["role_member_add"];
		post?: never;
		/** Role member remove */
		delete: operations["role_member_remove"];
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/room/{room_id}/tag": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Tag list room (TODO)
		 * @description List tags in a room?
		 */
		get: operations["tag_list_room"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/room/{room_id}/tag/{tag_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		/**
		 * Tag room apply (TODO)
		 * @description Apply a tag to a room
		 */
		put: operations["tag_room_apply"];
		post?: never;
		/**
		 * Tag room unapply (TODO)
		 * @description Unapply a tag from a room
		 */
		delete: operations["tag_room_unapply"];
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/room/{room_id}/tag/{tag_id}/permission/{overwrite_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		/**
		 * Tag permission override upsert(TODO)
		 * @description Upsert a tag permission override
		 */
		put: operations["permission_tag_override"];
		post?: never;
		/**
		 * Tag permission override delete (TODO)
		 * @description Delete a tag permission override
		 */
		delete: operations["permission_tag_delete"];
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/room/{room_id}/thread": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** List threads in a room */
		get: operations["thread_list"];
		put?: never;
		/** Create a thread */
		post: operations["thread_create"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/room/{room_id}/thread/{thread_id}/message/{message_id}/report": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Report message (TODO)
		 * @description Report a message
		 */
		post: operations["report_message"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/room/{room_id}/thread/{thread_id}/report": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Report thread (TODO)
		 * @description Report a thread
		 */
		post: operations["report_thread"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/room/{thread_id}/emoji": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Emoji list room (TODO)
		 * @description List emoji for a room.
		 */
		get: operations["emoji_list_room"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/search/message": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/** Search messages */
		post: operations["search_messages"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/search/room": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/** Search rooms (TODO) */
		post: operations["search_rooms"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/search/thread": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/** Search threads (TODO) */
		post: operations["search_threads"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/session": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Session list */
		get: operations["session_list"];
		put?: never;
		/** Session create */
		post: operations["session_create"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/session/{session_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Session get */
		get: operations["session_get"];
		put?: never;
		post?: never;
		/** Session delete */
		delete: operations["session_delete"];
		options?: never;
		head?: never;
		/** Session update */
		patch: operations["session_update"];
		trace?: never;
	};
	"/api/v1/tag": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Tag list user (TODO)
		 * @description List tags you have access to?
		 */
		get: operations["tag_list_user"];
		put?: never;
		/** Tag create (TODO) */
		post: operations["tag_create"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/tag/{tag_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Tag get (TODO) */
		get: operations["tag_get"];
		put?: never;
		post?: never;
		/** Tag delete (TODO) */
		delete: operations["tag_delete"];
		options?: never;
		head?: never;
		/** Tag patch (TODO) */
		patch: operations["tag_patch"];
		trace?: never;
	};
	"/api/v1/tag/{tag_id}/tag/{tag_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		/**
		 * Tag tag apply (TODO)
		 * @description Apply a tag to a tag
		 *
		 *     If tag a is tagged with tag b then any taggable tagged with tag a is implicitly tagged with tag b
		 */
		put: operations["tag_tag_apply"];
		post?: never;
		/**
		 * Tag tag unapply (TODO)
		 * @description Unapply a tag from a tag
		 */
		delete: operations["tag_tag_unapply"];
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/thread/{thread_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Get a thread */
		get: operations["thread_get"];
		put?: never;
		post?: never;
		/**
		 * Delete thread
		 * @description Set a thread's state to Deleted.
		 */
		delete: operations["thread_delete"];
		options?: never;
		head?: never;
		/** Edit a thread */
		patch: operations["thread_update"];
		trace?: never;
	};
	"/api/v1/thread/{thread_id}/ack": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		/**
		 * Ack thread
		 * @description Mark a thread as read (or unread).
		 */
		put: operations["thread_ack"];
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/thread/{thread_id}/activate": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		/**
		 * Reopen/unpin thread
		 * @description Set a thread's state to Default.
		 */
		put: operations["thread_activate"];
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/thread/{thread_id}/archive": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		/**
		 * Archive thread
		 * @description Set a thread's state to Archived.
		 */
		put: operations["thread_archive"];
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/thread/{thread_id}/context/{message_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get context for message
		 * @description More efficient than calling List messages twice
		 */
		get: operations["message_context"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/thread/{thread_id}/member": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Thread member list */
		get: operations["thread_member_list"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/thread/{thread_id}/member/{user_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Thread member get */
		get: operations["thread_member_get"];
		/** Thread member add */
		put: operations["thread_member_add"];
		post?: never;
		/** Thread member delete (kick/leave) */
		delete: operations["thread_member_delete"];
		options?: never;
		head?: never;
		/** Thread member update */
		patch: operations["thread_member_update"];
		trace?: never;
	};
	"/api/v1/thread/{thread_id}/message": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** List messages in a thread */
		get: operations["message_list"];
		put?: never;
		/** Create a message */
		post: operations["message_create"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/thread/{thread_id}/message/{message_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Get a message */
		get: operations["message_get"];
		put?: never;
		post?: never;
		/** Delete message */
		delete: operations["message_delete"];
		options?: never;
		head?: never;
		/** edit a message */
		patch: operations["message_edit"];
		trace?: never;
	};
	"/api/v1/thread/{thread_id}/message/{message_id}/reaction": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		post?: never;
		/**
		 * Message reaction purge (TODO)
		 * @description Remove all reactions from a message.
		 */
		delete: operations["reaction_message_purge"];
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/thread/{thread_id}/message/{message_id}/reaction/{key}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Message reaction list (TODO)
		 * @description List message reactions for a specific emoji.
		 */
		get: operations["reaction_message_list"];
		/**
		 * Message reaction add (TODO)
		 * @description Add a reaction to a message.
		 */
		put: operations["reaction_message_add"];
		post?: never;
		/**
		 * Message reaction remove (TODO)
		 * @description Remove a reaction from a message.
		 */
		delete: operations["reaction_message_remove"];
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/thread/{thread_id}/message/{message_id}/version": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** List message versions */
		get: operations["message_version_list"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/thread/{thread_id}/message/{message_id}/version/{version_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Get message version */
		get: operations["message_version_get"];
		put?: never;
		post?: never;
		/** Delete message version */
		delete: operations["message_version_delete"];
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/thread/{thread_id}/messages/bulk-delete": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/** Message delete bulk (TODO) */
		post: operations["message_delete_bulk"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/thread/{thread_id}/notifications": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		/**
		 * Notification edit thread (TODO)
		 * @description Edit notification settings for a thread.
		 */
		patch: operations["notification_edit_thread"];
		trace?: never;
	};
	"/api/v1/thread/{thread_id}/permission/{overwrite_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		/**
		 * Thread permission override upsert (TODO)
		 * @description Upsert a thread permission override
		 */
		put: operations["permission_thread_override"];
		post?: never;
		/**
		 * Thread permission override delete (TODO)
		 * @description Delete a thread permission override
		 */
		delete: operations["permission_thread_delete"];
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/thread/{thread_id}/pin": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		/**
		 * Pin thread
		 * @description Set a thread's state to Pinned.
		 */
		put: operations["thread_pin"];
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/thread/{thread_id}/reaction": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		post?: never;
		/**
		 * Thread reaction purge (TODO)
		 * @description Remove all reactions from a thread.
		 */
		delete: operations["reaction_thread_purge"];
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/thread/{thread_id}/reaction/{key}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Thread reaction list (TODO)
		 * @description List thread reactions for a specific emoji.
		 */
		get: operations["reaction_thread_list"];
		/**
		 * Thread reaction add (TODO)
		 * @description Add a reaction to a thread.
		 */
		put: operations["reaction_thread_add"];
		post?: never;
		/**
		 * Thread reaction remove (TODO)
		 * @description Remove a reaction from a thread.
		 */
		delete: operations["reaction_thread_remove"];
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/thread/{thread_id}/replies/{message_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Message replies (TODO) */
		get: operations["message_replies"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/thread/{thread_id}/tag/{tag_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		/**
		 * Tag thread apply (TODO)
		 * @description Apply a tag to a thread. For bulk applying tags, consider editing the thread's tags field directly.
		 */
		put: operations["tag_thread_apply"];
		post?: never;
		/**
		 * Tag thread unapply (TODO)
		 * @description Unapply a tag from a thread. For bulk removing tags, consider editing the thread's tags field directly.
		 */
		delete: operations["tag_thread_unapply"];
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/thread/{thread_id}/typing": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		/**
		 * Send typing
		 * @description Send a typing notification to a thread
		 */
		put: operations["thread_typing"];
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/user": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * User list (TODO)
		 * @description Lists every user you are able to see. Can be filtered with ?include
		 */
		get: operations["user_list"];
		put?: never;
		/** User create */
		post: operations["user_create"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/user/@self/dm/{target_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Dm get (TODO)
		 * @description Get a direct message room.
		 */
		get: operations["dm_get"];
		/**
		 * Dm initialize (TODO)
		 * @description Get or create a direct message room.
		 */
		put: operations["dm_init"];
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/user/@self/emoji": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Emoji list user (TODO)
		 * @description List emoji for a user.
		 */
		get: operations["emoji_list_user"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/user/@self/relationship/{target_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Relationship get (TODO)
		 * @description Get your relationship with another user
		 */
		get: operations["relationship_get"];
		put?: never;
		post?: never;
		/**
		 * Relationship remove (TODO)
		 * @description Reset your relationship with another user
		 */
		delete: operations["relationship_reset"];
		options?: never;
		head?: never;
		/**
		 * Relationship update (TODO)
		 * @description Update your relationship with another user
		 */
		patch: operations["relationship_update"];
		trace?: never;
	};
	"/api/v1/user/{user_id}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** User get */
		get: operations["user_get"];
		put?: never;
		post?: never;
		/** User delete */
		delete: operations["user_delete"];
		options?: never;
		head?: never;
		/** User update */
		patch: operations["user_update"];
		trace?: never;
	};
	"/api/v1/user/{user_id}/config": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * User config get (TODO)
		 * @description Get user config
		 */
		get: operations["user_config_get"];
		/**
		 * User config set (TODO)
		 * @description Set user config
		 */
		put: operations["user_config_set"];
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/user/{user_id}/email": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Email list */
		get: operations["email_list"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/user/{user_id}/email/{addr}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Email get */
		get: operations["email_get"];
		/** Email add */
		put: operations["email_add"];
		post?: never;
		/** Email delete */
		delete: operations["email_delete"];
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/user/{user_id}/email/{addr}/verify": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/** Email resend verification email */
		post: operations["email_resent_verification"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/user/{user_id}/invite": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Invite user create (TODO)
		 * @description Create an invite that goes to a user
		 */
		post: operations["invite_user_create"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/user/{user_id}/relationship": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Relationship list (TODO)
		 * @description List relationships with other users. Passing in someone else's id lists
		 *     mutual friends.
		 */
		get: operations["relationship_list"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/user/{user_id}/report": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Report user (TODO)
		 * @description Report a user
		 */
		post: operations["report_user"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/user/{user_id}/room": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Mutual rooms list (TODO)
		 * @description List rooms both you and the target are in. Calling it on yourself lists
		 *     rooms you're in.
		 */
		get: operations["mutual_room_list"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/users/{user_id}/invite": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Invite user list (TODO)
		 * @description List invites that go to a user
		 */
		get: operations["invite_user_list"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
}
export type webhooks = Record<string, never>;
export interface components {
	schemas: {
		AckReq: {
			message_id?: null | components["schemas"]["MessageId"];
			/** @description The last read id in this thread. Currently unused, may be deprecated later? */
			version_id: components["schemas"]["MessageVerId"];
		};
		/** @description metadata for audio */
		Audio: {
			codec: string;
			/** Format: int64 */
			duration: number;
			language?: null | components["schemas"]["Language"];
		};
		AuditLog: {
			/** @description Unique id idenfitying this entry */
			id: components["schemas"]["AuditLogId"];
			/** @description Generated sync payload (sent in websocket) */
			payload: components["schemas"]["MessageSync"];
			payload_prev?: null | components["schemas"]["MessageSync"];
			/** @description User supplied reason why this happened */
			reason?: string | null;
			/** @description Room this happened in */
			room_id: components["schemas"]["RoomId"];
			/** @description User who caused this entry to be created */
			user_id: components["schemas"]["UserId"];
		};
		/** Format: uuid */
		AuditLogId: string;
		AuthStatus: {
			/** @description if a password has been set */
			has_password: boolean;
			/** @description if local totp state is_valid */
			has_totp: boolean;
			/** @description if there is at least one verified email address */
			has_verified_email: boolean;
			/** @description the oauth providers this user has authenticated with */
			oauth_providers: string[];
		};
		BotOwner: {
			/** @enum {string} */
			owner_type: "Thread";
			thread_id: components["schemas"]["ThreadId"];
		} | {
			/** @enum {string} */
			owner_type: "Room";
			room_id: components["schemas"]["RoomId"];
		} | {
			/** @enum {string} */
			owner_type: "User";
			user_id: components["schemas"]["UserId"];
		} | {
			/** @enum {string} */
			owner_type: "Server";
		};
		BotVisibility: "Private" | {
			/** @description anyone can use the bot */
			Public: {
				/** @description anyone can search for and find this; otherwise, this is unlisted */
				is_discoverable: boolean;
			};
		};
		CaptchaChallenge: {
			code: string;
		};
		CaptchaResponse: {
			code: string;
		};
		/** @description a color */
		Color: string;
		ContextResponse: {
			has_after: boolean;
			has_before: boolean;
			items: components["schemas"]["Message"][];
			/** Format: int64 */
			total: number;
		};
		/** @description An email address */
		EmailAddr: {
			inner: string;
		};
		EmailInfo: {
			/** @description the email address itself */
			email: components["schemas"]["EmailAddr"];
			/** @description whether this is the user's primary email address */
			is_primary: boolean;
			/** @description can see by everyone */
			is_public: boolean;
			/** @description user verified they have access to the email address */
			is_verified: boolean;
			/** @description can someone with access to email can do */
			trust: components["schemas"]["EmailTrust"];
		};
		/**
		 * @description what someone can do with this email address
		 * @enum {string}
		 */
		EmailTrust: "Never" | "Trusted" | "Full";
		Emoji:
			| components["schemas"]["EmojiCustom"]
			| components["schemas"]["EmojiUnicode"];
		EmojiCustom: {
			animated: boolean;
			creator_id: components["schemas"]["UserId"];
			id: components["schemas"]["EmojiId"];
			media_id: components["schemas"]["MediaId"];
			name: string;
			owner: components["schemas"]["EmojiOwner"];
		};
		EmojiCustomCreate: {
			animated: boolean;
			media_id: components["schemas"]["MediaId"];
			name: string;
			owner: components["schemas"]["EmojiOwner"];
		};
		EmojiCustomPatch: {
			name?: string | null;
			owner?: null | components["schemas"]["EmojiOwner"];
		};
		/** Format: uuid */
		EmojiId: string;
		EmojiOwner: {
			/** @enum {string} */
			owner: "Room";
			room_id: components["schemas"]["RoomId"];
		} | {
			/** @enum {string} */
			owner: "User";
		};
		/** @description a single unicode emoji */
		EmojiUnicode: string;
		ExternalPlatform: null | string;
		/** @description how a user is ignoring another user */
		Ignore: {
			/** @enum {string} */
			ignore: "Until";
			ignore_until: components["schemas"]["Time"];
		} | {
			/** @enum {string} */
			ignore: "Forever";
		};
		/** @description metadata for images */
		Image: {
			/** Format: int64 */
			height: number;
			language?: null | components["schemas"]["Language"];
			/** Format: int64 */
			width: number;
		};
		/** @enum {string} */
		InboxFilter:
			| "Reminder"
			| "MentionsUser"
			| "MentionsBulk"
			| "Reply"
			| "JoinedUnread"
			| "Suggestion"
			| "IncludeRead"
			| "IncludeMuted";
		/** @description Which notifications to include */
		InboxFilters: components["schemas"]["InboxFilter"][];
		InboxPatch: {
			/** @description add something to the thread as a notification */
			add?: components["schemas"]["InboxPatchAdd"][];
			/** @description mark notifications as read */
			mark_read?: components["schemas"]["InboxPatchRead"][];
			/** @description mark notifications as unread */
			mark_unread?: components["schemas"]["InboxPatchUnread"][];
			prune_before?: null | components["schemas"]["Time"];
		};
		InboxPatchAdd: {
			added_at?: null | components["schemas"]["Time"];
			room_id: components["schemas"]["RoomId"];
			thread_id: components["schemas"]["ThreadId"];
			/** @enum {string} */
			type: "Thread";
		} | {
			added_at?: null | components["schemas"]["Time"];
			message_id: components["schemas"]["MessageId"];
			room_id: components["schemas"]["RoomId"];
			thread_id: components["schemas"]["ThreadId"];
			/** @enum {string} */
			type: "Message";
		};
		InboxPatchRead: {
			read_at?: null | components["schemas"]["Time"];
			room_id: components["schemas"]["RoomId"];
			thread_id: components["schemas"]["ThreadId"];
			/** @enum {string} */
			type: "Thread";
		} | {
			message_id: components["schemas"]["MessageId"];
			read_at?: null | components["schemas"]["Time"];
			room_id: components["schemas"]["RoomId"];
			thread_id: components["schemas"]["ThreadId"];
			/** @enum {string} */
			type: "Message";
		};
		InboxPatchUnread: {
			room_id: components["schemas"]["RoomId"];
			thread_id: components["schemas"]["ThreadId"];
			/** @enum {string} */
			type: "Thread";
		} | {
			message_id: components["schemas"]["MessageId"];
			room_id: components["schemas"]["RoomId"];
			thread_id: components["schemas"]["ThreadId"];
			/** @enum {string} */
			type: "Message";
		};
		Invite: {
			/** @description the invite code for this invite */
			code: components["schemas"]["InviteCode"];
			/** @description the time when this invite was created */
			created_at: components["schemas"]["Time"];
			/** @description the user who created this invite */
			creator: components["schemas"]["User"];
			/** @description the id of the user who created this invite */
			creator_id: components["schemas"]["UserId"];
			/** @description a description for this invite */
			description?: string | null;
			expires_at?: null | components["schemas"]["Time"];
			/** @description if this invite's code is custom (instead of random) */
			is_vanity: boolean;
			/** @description where this invite leads */
			target: components["schemas"]["InviteTarget"];
		};
		/** @description a short, unique identifier. knowing the code grants access to the invite's target. */
		InviteCode: string;
		InviteCreate: {
			/** @description a description for this invite */
			description?: string | null;
			expires_at?: null | components["schemas"]["Time"];
			/**
			 * Format: int64
			 * @description the maximum number of times this invite can be used
			 *     be sure to account for existing `uses` and `max_uses` when patching
			 */
			max_uses?: number | null;
		};
		InvitePatch: {
			/** @description a description for this invite */
			description?: string | null;
			expires_at?: null | components["schemas"]["Time"];
			/**
			 * Format: int64
			 * @description the maximum number of times this invite can be used
			 *     be sure to account for existing `uses` and `max_uses` when patching
			 */
			max_uses?: number | null;
		};
		/** @description where this invite leads */
		InviteTarget: {
			/** @enum {string} */
			type: "User";
			user: components["schemas"]["User"];
		} | {
			room: components["schemas"]["Room"];
			/** @enum {string} */
			type: "Room";
		} | {
			room: components["schemas"]["Room"];
			thread: components["schemas"]["Thread"];
			/** @enum {string} */
			type: "Thread";
		};
		/** @description the type and id of this invite's target */
		InviteTargetId: {
			/** @enum {string} */
			type: "User";
			user_id: components["schemas"]["UserId"];
		} | {
			room_id: components["schemas"]["RoomId"];
			/** @enum {string} */
			type: "Room";
		} | {
			room_id: components["schemas"]["RoomId"];
			thread_id: components["schemas"]["ThreadId"];
			/** @enum {string} */
			type: "Thread";
		};
		InviteWithMetadata: components["schemas"]["Invite"] & {
			/**
			 * Format: int64
			 * @description the maximum number of times this invite can be used
			 */
			max_uses?: number | null;
			/**
			 * Format: int64
			 * @description the number of time this invite has been used
			 */
			uses: number;
		};
		/** @description a language */
		Language: string;
		/** @description A distinct logical item of media. */
		Media: {
			/** @description Descriptive alt text, not entirely unlike a caption */
			alt?: string | null;
			/** @description The original filename */
			filename: string;
			id: components["schemas"]["MediaId"];
			/** @description The source (Uploaded, Downloaded) */
			source: components["schemas"]["MediaTrack"];
			/** @description The source (Extracted, Generated) */
			tracks: components["schemas"]["MediaTrack"][];
		};
		MediaCreate: components["schemas"]["MediaCreateSource"] & {
			/** @description Descriptive alt text, not entirely unlike a caption */
			alt?: string | null;
		};
		MediaCreateSource: {
			/** @description The original filename */
			filename?: string;
			/**
			 * Format: int64
			 * @description The size (in bytes)
			 */
			size: number;
		} | {
			/** @description The original filename */
			filename?: string | null;
			/**
			 * Format: int64
			 * @description The size (in bytes)
			 */
			size?: number | null;
			/**
			 * Format: uri
			 * @description A url to download this media from
			 */
			source_url: string;
		};
		MediaCreated: {
			media_id: components["schemas"]["MediaId"];
			/**
			 * Format: uri
			 * @description A url to download your media to
			 */
			upload_url?: string | null;
		};
		/** Format: uuid */
		MediaId: string;
		MediaPatch: {
			/** @description Descriptive alt text, not entirely unlike a caption */
			alt?: string | null;
		};
		MediaRef: {
			id: components["schemas"]["MediaId"];
		};
		MediaSize: {
			/**
			 * Format: int64
			 * @description if the size is known
			 */
			size: number;
			/** @enum {string} */
			size_unit: "Bytes";
		} | {
			/**
			 * Format: int64
			 * @description approximate bandwidth if the size is unknown (media streaming)
			 */
			size: number;
			/** @enum {string} */
			size_unit: "BytesPerSecond";
		};
		/** @description A unique "view" of this piece of media. Could be the source, an
		 *     audio/video track, a thumbnail, other metadata, etc. */
		MediaTrack:
			& components["schemas"]["MediaTrackInfo"]
			& components["schemas"]["MediaSize"]
			& components["schemas"]["TrackSource"]
			& {
				/** @description the mime type of this view */
				mime: components["schemas"]["Mime"];
				/**
				 * Format: uri
				 * @description The url where this track may be downloaded from
				 */
				url: string;
			};
		/** @description metadata about a particular track */
		MediaTrackInfo:
			| (components["schemas"]["Video"] & {
				/** @enum {string} */
				type: "Video";
			})
			| (components["schemas"]["Audio"] & {
				/** @enum {string} */
				type: "Audio";
			})
			| (components["schemas"]["Image"] & {
				/** @enum {string} */
				type: "Image";
			})
			| (components["schemas"]["Image"] & {
				/** @enum {string} */
				type: "Thumbnail";
			})
			| (components["schemas"]["TimedText"] & {
				/** @enum {string} */
				type: "TimedText";
			})
			| (components["schemas"]["Text"] & {
				/** @enum {string} */
				type: "Text";
			})
			| (components["schemas"]["Mixed"] & {
				/** @enum {string} */
				type: "Mixed";
			})
			| {
				/** @enum {string} */
				type: "Other";
			};
		/** @description who/what this message notified on send */
		Mentions: {
			/** @description if this mentioned everyone in the room */
			mentions_all_in_room: boolean;
			/** @description if this mentioned everyone in the thread */
			mentions_all_in_thread: boolean;
			mentions_roles: components["schemas"]["RoleId"][];
			mentions_rooms: components["schemas"]["ThreadId"][];
			mentions_threads: components["schemas"]["ThreadId"][];
			mentions_users: components["schemas"]["UserId"][];
		};
		Message:
			& components["schemas"]["MessageType"]
			& components["schemas"]["Mentions"]
			& components["schemas"]["MessageState"]
			& {
				/** @description who sent this message
				 *
				 *     deprecated: use author_id and fetch manually, better caching and easier server impl */
				author: components["schemas"]["User"];
				/** @description the id of who sent this message */
				author_id: components["schemas"]["UserId"];
				id: components["schemas"]["MessageId"];
				/**
				 * @deprecated
				 * @description if this message is pinned
				 *
				 *     deprecated: use message.state
				 */
				is_pinned: boolean;
				/** @description unique string sent by the client to identify this message
				 *     maybe i will replace with a header so nonces can be used everywhere */
				nonce?: string | null;
				/**
				 * Format: int32
				 * @deprecated
				 * @description the index/position/ordering of this message in the thread
				 *
				 *     deprecated: not that useful
				 */
				ordering: number;
				state_updated_at: components["schemas"]["Time"];
				thread_id: components["schemas"]["ThreadId"];
				version_id: components["schemas"]["MessageVerId"];
			};
		/** @description a bot command */
		MessageBotCommand: {
			command_id: string;
		};
		MessageCreate: {
			attachments?: components["schemas"]["MediaRef"][];
			/** @description the message's content, in either markdown or the new format depending on if use_new_text_formatting is true */
			content?: string | null;
			/**
			 * @deprecated
			 * @description arbitrary metadata associated with a message
			 *
			 *     deprecated: arbitrary metadata is too dubious, sorry. will come up with a better solution later
			 */
			metadata?: unknown;
			/**
			 * @deprecated
			 * @description used so the client can know if the message was sent or not
			 *
			 *     deprecated: Ideompotency-Key
			 */
			nonce?: string | null;
			/**
			 * @deprecated
			 * @description override the name of this message's sender
			 *
			 *     deprecated: create new puppets for each bridged user instead
			 */
			override_name?: string | null;
			reply_id?: null | components["schemas"]["MessageId"];
			/** @description uses the new new formatting system if true, otherwise uses markdown */
			use_new_text_formatting?: boolean;
		};
		/** @description a basic message, using the legacy markdown syntax
		 *
		 *     NOTE: new message features won't be backported here! */
		MessageDefaultMarkdown: {
			attachments: components["schemas"]["Media"][];
			/** @description the message's content in markdown */
			content?: string | null;
			embeds: components["schemas"]["UrlEmbed"][];
			/**
			 * @deprecated
			 * @description arbitrary metadata associated with a message
			 *
			 *     deprecated: arbitrary metadata is too dubious, sorry. will come up with a better solution later
			 */
			metadata?: unknown;
			/**
			 * @deprecated
			 * @description override the name of this message's sender
			 *
			 *     deprecated: create new puppets for each bridged user instead
			 */
			override_name?: string | null;
			reply_id?: null | components["schemas"]["MessageId"];
		};
		MessageDeleteBulk: {
			/** @description which messages to delete */
			message_id?: components["schemas"]["MessageId"][];
		};
		/** Format: uuid */
		MessageId: string;
		/** @description Information about a member being added or removed from a thread */
		MessageMember: {
			actor_user_id: components["schemas"]["UserId"];
			reason?: string | null;
			target_user_id: components["schemas"]["UserId"];
		};
		/** @description audit log entries as a message (builtin moderation logging?) */
		MessageModerationLog: {
			audit_log_entry: components["schemas"]["AuditLog"];
		};
		/** @description a report that moderators should look at */
		MessageModerationReport: {
			report: components["schemas"]["Report"];
		};
		MessagePatch: {
			attachments?: components["schemas"]["MediaRef"][] | null;
			/** @description the new message content. whether its markdown/new format depends on the target message's format */
			content?: string | null;
			/**
			 * @deprecated
			 * @description arbitrary metadata associated with a message
			 *
			 *     deprecated: arbitrary metadata is too dubious, sorry. will come up with a better solution later
			 */
			metadata?: unknown;
			/**
			 * @deprecated
			 * @description override the name of this message's sender
			 *
			 *     deprecated: create new puppets for each bridged user instead
			 */
			override_name?: string | null;
			reply_id?: null | components["schemas"]["MessageId"];
		};
		/** @description Information about a message being pinned or unpinned */
		MessagePin: {
			message_id: components["schemas"]["MessageId"];
			reason?: string | null;
			user_id: components["schemas"]["UserId"];
		};
		/** @description Following a room and will receive announcement posts from it */
		MessageRoomFollowed: {
			reason?: string | null;
			thread_id: components["schemas"]["ThreadId"];
			user_id: components["schemas"]["UserId"];
		};
		/** @description lifecycle of a message */
		MessageState: {
			/** @enum {string} */
			state: "Default";
		} | {
			/** Format: int32 */
			pin_order: number;
			/** @enum {string} */
			state: "Pinned";
		} | {
			/** @enum {string} */
			state: "Ephemeral";
		} | {
			/** @enum {string} */
			state: "Deleted";
		};
		MessageSync: {
			room: components["schemas"]["Room"];
			/** @enum {string} */
			type: "UpsertRoom";
		} | {
			thread: components["schemas"]["Thread"];
			/** @enum {string} */
			type: "UpsertThread";
		} | {
			message: components["schemas"]["Message"];
			/** @enum {string} */
			type: "UpsertMessage";
		} | {
			/** @enum {string} */
			type: "UpsertUser";
			user: components["schemas"]["User"];
		} | {
			member: components["schemas"]["RoomMember"];
			/** @enum {string} */
			type: "UpsertRoomMember";
		} | {
			member: components["schemas"]["ThreadMember"];
			/** @enum {string} */
			type: "UpsertThreadMember";
		} | {
			session: components["schemas"]["Session"];
			/** @enum {string} */
			type: "UpsertSession";
		} | {
			role: components["schemas"]["Role"];
			/** @enum {string} */
			type: "UpsertRole";
		} | {
			invite: components["schemas"]["InviteWithMetadata"];
			/** @enum {string} */
			type: "UpsertInvite";
		} | {
			message_id: components["schemas"]["MessageId"];
			/** @description deprecated = "keyed by thread_id" */
			room_id: components["schemas"]["RoomId"];
			thread_id: components["schemas"]["ThreadId"];
			/** @enum {string} */
			type: "DeleteMessage";
		} | {
			message_id: components["schemas"]["MessageId"];
			/** @description deprecated = "keyed by thread_id" */
			room_id: components["schemas"]["RoomId"];
			thread_id: components["schemas"]["ThreadId"];
			/** @enum {string} */
			type: "DeleteMessageVersion";
			version_id: components["schemas"]["MessageVerId"];
		} | {
			id: components["schemas"]["UserId"];
			/** @enum {string} */
			type: "DeleteUser";
		} | {
			id: components["schemas"]["SessionId"];
			/** @enum {string} */
			type: "DeleteSession";
			user_id?: null | components["schemas"]["UserId"];
		} | {
			role_id: components["schemas"]["RoleId"];
			room_id: components["schemas"]["RoomId"];
			/** @enum {string} */
			type: "DeleteRole";
		} | {
			code: components["schemas"]["InviteCode"];
			target: components["schemas"]["InviteTargetId"];
			/** @enum {string} */
			type: "DeleteInvite";
		} | {
			thread_id: components["schemas"]["ThreadId"];
			/** @enum {string} */
			type: "Typing";
			until: components["schemas"]["Time"];
			user_id: components["schemas"]["UserId"];
		} | {
			message_id: components["schemas"]["MessageId"];
			thread_id: components["schemas"]["ThreadId"];
			/** @enum {string} */
			type: "ThreadAck";
			version_id: components["schemas"]["MessageVerId"];
		} | {
			relationship: components["schemas"]["Relationship"];
			/** @enum {string} */
			type: "RelationshipUpsert";
			user_id: components["schemas"]["UserId"];
		} | {
			/** @enum {string} */
			type: "RelationshipDelete";
			user_id: components["schemas"]["UserId"];
		};
		/** @description a message (announcement? motd?) from the system */
		MessageSystemMessage: {
			attachments: components["schemas"]["Media"][];
			content?: string | null;
			embeds: components["schemas"]["UrlEmbed"][];
		};
		/** @description Information about the pingback */
		MessageThreadPingback: {
			source_room_id: components["schemas"]["RoomId"];
			source_thread_id: components["schemas"]["ThreadId"];
		};
		/** @description Information about a thread being updated */
		MessageThreadUpdate: {
			patch: components["schemas"]["ThreadPatch"];
		};
		MessageType:
			| (components["schemas"]["MessageDefaultMarkdown"] & {
				/** @enum {string} */
				type: "DefaultMarkdown";
			})
			| (components["schemas"]["MessagePin"] & {
				/** @enum {string} */
				type: "MessagePinned";
			})
			| (components["schemas"]["MessagePin"] & {
				/** @enum {string} */
				type: "MessageUnpinned";
			})
			| (components["schemas"]["MessageMember"] & {
				/** @enum {string} */
				type: "MemberAdd";
			})
			| (components["schemas"]["MessageMember"] & {
				/** @enum {string} */
				type: "MemberRemove";
			})
			| (components["schemas"]["MessageThreadUpdate"] & {
				/** @enum {string} */
				type: "ThreadUpdate";
			})
			| (components["schemas"]["MessageThreadUpdate"] & {
				/** @enum {string} */
				type: "ThreadCreate";
			})
			| (components["schemas"]["MessageThreadPingback"] & {
				/** @enum {string} */
				type: "ThreadPingback";
			})
			| (components["schemas"]["MessageRoomFollowed"] & {
				/** @enum {string} */
				type: "RoomFollowed";
			})
			| (components["schemas"]["MessageBotCommand"] & {
				/** @enum {string} */
				type: "BotCommand";
			})
			| (components["schemas"]["MessageModerationLog"] & {
				/** @enum {string} */
				type: "ModerationLog";
			})
			| (components["schemas"]["MessageModerationReport"] & {
				/** @enum {string} */
				type: "ModerationReport";
			})
			| (components["schemas"]["MessageSystemMessage"] & {
				/** @enum {string} */
				type: "SystemMessage";
			});
		/** Format: uuid */
		MessageVerId: string;
		/**
		 * Mime
		 * @description a mime/media type
		 */
		Mime: string;
		/** @description multiple pieces of metadata mixed together */
		Mixed: {
			/** Format: int64 */
			duration?: number | null;
			/** Format: int64 */
			height?: number | null;
			language?: null | components["schemas"]["Language"];
			/** Format: int64 */
			width?: number | null;
		};
		/** @description how long to mute for */
		MuteDuration: "Forever" | {
			Until: components["schemas"]["Time"];
		};
		/**
		 * @description how to handle an event
		 * @enum {string}
		 */
		NotifAction: "Notify" | "Watching" | "Ignore";
		/** @description a notification; a unit of stuff that may show up in your inbox or be pushed to you */
		Notification: components["schemas"]["NotificationInfo"] & {
			/** @description when this notification was created
			 *     can be set in the future to create a reminder */
			added_at: components["schemas"]["Time"];
			read_at?: null | components["schemas"]["Time"];
		};
		NotificationInfo: {
			reason: components["schemas"]["NotificationReasonThread"];
			room_id: components["schemas"]["RoomId"];
			thread_id: components["schemas"]["ThreadId"];
			/** @enum {string} */
			type: "Thread";
		} | {
			message_id: components["schemas"]["MessageId"];
			reason: components["schemas"]["NotificationReasonMessage"];
			room_id: components["schemas"]["RoomId"];
			thread_id: components["schemas"]["ThreadId"];
			/** @enum {string} */
			type: "Message";
		};
		/** @enum {string} */
		NotificationReasonMessage:
			| "Reminder"
			| "MentionsUser"
			| "MentionsBulk"
			| "Reply";
		/** @enum {string} */
		NotificationReasonThread: "Reminder" | "JoinedUnread" | "Suggestion";
		/** @description notification config for a user (works globally) */
		NotifsGlobal: {
			mentions: components["schemas"]["NotifAction"];
			messages: components["schemas"]["NotifAction"];
			mute?: null | components["schemas"]["MuteDuration"];
			room_dm: components["schemas"]["NotifAction"];
			room_private: components["schemas"]["NotifAction"];
			room_public: components["schemas"]["NotifAction"];
			threads: components["schemas"]["NotifAction"];
		};
		/** @description notification config for a room */
		NotifsRoom: {
			mentions?: null | components["schemas"]["NotifAction"];
			messages?: null | components["schemas"]["NotifAction"];
			mute?: null | components["schemas"]["MuteDuration"];
			threads?: null | components["schemas"]["NotifAction"];
		};
		/** @description notification config for a thread */
		NotifsThread: {
			mentions?: null | components["schemas"]["NotifAction"];
			messages?: null | components["schemas"]["NotifAction"];
			mute?: null | components["schemas"]["MuteDuration"];
		};
		OauthInitResponse: {
			/** Format: uri */
			url: string;
		};
		/** @enum {string} */
		PaginationDirection: "f" | "b";
		PaginationQuery_MessageId: {
			dir?: null | components["schemas"]["PaginationDirection"];
			/** Format: uuid */
			from?: string;
			/**
			 * Format: int32
			 * @description The maximum number of items to return.
			 */
			limit?: number | null;
			/** Format: uuid */
			to?: string;
		};
		PaginationResponse_AuditLog: {
			has_more: boolean;
			items: {
				/** @description Unique id idenfitying this entry */
				id: components["schemas"]["AuditLogId"];
				/** @description Generated sync payload (sent in websocket) */
				payload: components["schemas"]["MessageSync"];
				payload_prev?: null | components["schemas"]["MessageSync"];
				/** @description User supplied reason why this happened */
				reason?: string | null;
				/** @description Room this happened in */
				room_id: components["schemas"]["RoomId"];
				/** @description User who caused this entry to be created */
				user_id: components["schemas"]["UserId"];
			}[];
			/** Format: int64 */
			total: number;
		};
		PaginationResponse_EmojiCustom: {
			has_more: boolean;
			items: {
				animated: boolean;
				creator_id: components["schemas"]["UserId"];
				id: components["schemas"]["EmojiId"];
				media_id: components["schemas"]["MediaId"];
				name: string;
				owner: components["schemas"]["EmojiOwner"];
			}[];
			/** Format: int64 */
			total: number;
		};
		PaginationResponse_Invite: {
			has_more: boolean;
			items: {
				/** @description the invite code for this invite */
				code: components["schemas"]["InviteCode"];
				/** @description the time when this invite was created */
				created_at: components["schemas"]["Time"];
				/** @description the user who created this invite */
				creator: components["schemas"]["User"];
				/** @description the id of the user who created this invite */
				creator_id: components["schemas"]["UserId"];
				/** @description a description for this invite */
				description?: string | null;
				expires_at?: null | components["schemas"]["Time"];
				/** @description if this invite's code is custom (instead of random) */
				is_vanity: boolean;
				/** @description where this invite leads */
				target: components["schemas"]["InviteTarget"];
			}[];
			/** Format: int64 */
			total: number;
		};
		PaginationResponse_Message: {
			has_more: boolean;
			items: (
				& components["schemas"]["MessageType"]
				& components["schemas"]["Mentions"]
				& components["schemas"]["MessageState"]
				& {
					/** @description who sent this message
					 *
					 *     deprecated: use author_id and fetch manually, better caching and easier server impl */
					author: components["schemas"]["User"];
					/** @description the id of who sent this message */
					author_id: components["schemas"]["UserId"];
					id: components["schemas"]["MessageId"];
					/**
					 * @deprecated
					 * @description if this message is pinned
					 *
					 *     deprecated: use message.state
					 */
					is_pinned: boolean;
					/** @description unique string sent by the client to identify this message
					 *     maybe i will replace with a header so nonces can be used everywhere */
					nonce?: string | null;
					/**
					 * Format: int32
					 * @deprecated
					 * @description the index/position/ordering of this message in the thread
					 *
					 *     deprecated: not that useful
					 */
					ordering: number;
					state_updated_at: components["schemas"]["Time"];
					thread_id: components["schemas"]["ThreadId"];
					version_id: components["schemas"]["MessageVerId"];
				}
			)[];
			/** Format: int64 */
			total: number;
		};
		PaginationResponse_Notification: {
			has_more: boolean;
			items: (components["schemas"]["NotificationInfo"] & {
				/** @description when this notification was created
				 *     can be set in the future to create a reminder */
				added_at: components["schemas"]["Time"];
				read_at?: null | components["schemas"]["Time"];
			})[];
			/** Format: int64 */
			total: number;
		};
		PaginationResponse_ReactionListItem: {
			has_more: boolean;
			items: {
				user_id: components["schemas"]["UserId"];
			}[];
			/** Format: int64 */
			total: number;
		};
		PaginationResponse_Relationship: {
			has_more: boolean;
			items: ((null | components["schemas"]["Ignore"]) & {
				/** @description whatever you want to write */
				note?: string | null;
				/** @description personal petname for this user */
				petname?: string | null;
				relation?: null | components["schemas"]["RelationshipType"];
			})[];
			/** Format: int64 */
			total: number;
		};
		PaginationResponse_Role: {
			has_more: boolean;
			items: {
				description?: string | null;
				id: components["schemas"]["RoleId"];
				is_default: boolean;
				is_mentionable: boolean;
				is_self_applicable: boolean;
				name: string;
				permissions: components["schemas"]["Permission"][];
				room_id: components["schemas"]["RoomId"];
				version_id: components["schemas"]["RoleVerId"];
			}[];
			/** Format: int64 */
			total: number;
		};
		PaginationResponse_Room: {
			has_more: boolean;
			items: (components["schemas"]["RoomType"] & {
				default_layout: components["schemas"]["ThreadsLayout"];
				default_order: components["schemas"]["ThreadsOrder"];
				description?: string | null;
				/** @description A unique identifier for this room */
				id: components["schemas"]["RoomId"];
				/** @description list of preferred locales, in order of most to least preferred */
				languages: components["schemas"]["Language"][];
				/**
				 * Format: int64
				 * @description number of people in this room
				 */
				member_count: number;
				name: string;
				/**
				 * Format: int64
				 * @description number of people who are online in this room
				 */
				online_count: number;
				system_messages?: null | components["schemas"]["ThreadId"];
				/** @description tags that are applied to this room */
				tags_applied: components["schemas"]["TagId"][];
				/**
				 * @deprecated
				 * @description tags that can be used in threads
				 */
				tags_available: components["schemas"]["TagId"][];
				/**
				 * Format: int64
				 * @description number of active threads
				 */
				thread_count: number;
				/**
				 * Format: uuid
				 * @description A monotonically increasing id that is updated every time this room is modified.
				 */
				version_id: string;
				visibility: components["schemas"]["RoomVisibility"];
			})[];
			/** Format: int64 */
			total: number;
		};
		PaginationResponse_RoomMember: {
			has_more: boolean;
			items: (components["schemas"]["RoomMembership"] & {
				/** @description When this member's membership last changed (joined, left, was kicked, or banned). */
				membership_updated_at: components["schemas"]["Time"];
				room_id: components["schemas"]["RoomId"];
				user_id: components["schemas"]["UserId"];
			})[];
			/** Format: int64 */
			total: number;
		};
		PaginationResponse_Session: {
			has_more: boolean;
			items: (components["schemas"]["SessionStatus"] & {
				id: components["schemas"]["SessionId"];
				name?: string | null;
			})[];
			/** Format: int64 */
			total: number;
		};
		PaginationResponse_Tag: {
			has_more: boolean;
			items: {
				color?: null | components["schemas"]["Color"];
				description?: string | null;
				id: components["schemas"]["TagId"];
				/** @description whether this tag is archived. cant be applied to any new threads or appear in pickers but still exists. */
				is_archived: boolean;
				name: string;
				room_id: components["schemas"]["RoomId"];
				version_id: components["schemas"]["TagVerId"];
			}[];
			/** Format: int64 */
			total: number;
		};
		PaginationResponse_Thread: {
			has_more: boolean;
			items: (
				& components["schemas"]["ThreadPublic"]
				& (null | components["schemas"]["ThreadPrivate"])
				& {
					creator_id: components["schemas"]["UserId"];
					description?: string | null;
					id: components["schemas"]["ThreadId"];
					/** @description if this should be treated as an announcement
					 *     contents will be copied into a new room in all following room */
					is_announcement: boolean;
					/** @description if this thread is locked and cannot be interacted with anymore */
					is_locked: boolean;
					/**
					 * Format: int64
					 * @description number of people in this room
					 *     does not not update with ThreadSync
					 */
					member_count: number;
					name: string;
					/**
					 * Format: int64
					 * @description number of people who are online in this room
					 *     does not not update with ThreadSync
					 */
					online_count: number;
					/** @description emoji reactions to this thread */
					reactions: components["schemas"]["ReactionCounts"];
					room_id: components["schemas"]["RoomId"];
					state: components["schemas"]["ThreadState"];
					state_updated_at: components["schemas"]["Time"];
					/** @description tags that are applied to this thread */
					tags: components["schemas"]["TagId"][];
					/** @description only updates when the thread itself is updated, not the stuff in the thread */
					version_id: components["schemas"]["ThreadVerId"];
					/** @description who can see this thread */
					visibility: components["schemas"]["ThreadVisibility"];
				}
			)[];
			/** Format: int64 */
			total: number;
		};
		PaginationResponse_ThreadMember: {
			has_more: boolean;
			items: (components["schemas"]["ThreadMembership"] & {
				/** @description When this member's membership last changed (joined, left, was kicked, or banned). */
				membership_updated_at: components["schemas"]["Time"];
				thread_id: components["schemas"]["ThreadId"];
				user_id: components["schemas"]["UserId"];
			})[];
			/** Format: int64 */
			total: number;
		};
		PaginationResponse_User: {
			has_more: boolean;
			items: (components["schemas"]["UserType"] & {
				avatar?: null | components["schemas"]["MediaId"];
				description?: string | null;
				id: components["schemas"]["UserId"];
				name: string;
				state: components["schemas"]["UserState"];
				state_updated_at: components["schemas"]["Time"];
				status: components["schemas"]["Status"];
				version_id: components["schemas"]["UserVerId"];
			})[];
			/** Format: int64 */
			total: number;
		};
		PasswordExec: components["schemas"]["PasswordExecIdent"] & {
			password: string;
		};
		/** @description who's logging in */
		PasswordExecIdent: {
			/** @enum {string} */
			type: "UserId";
			user_id: components["schemas"]["UserId"];
		} | {
			email: components["schemas"]["EmailAddr"];
			/** @enum {string} */
			type: "Email";
		};
		PasswordSet: {
			password: string;
		};
		/**
		 * @description a permission that lets a user do something
		 *
		 *     - unimplemented: the feature this permission refers to does not yet exist
		 *     - internal: this is calculated by the server and cannot be manually added
		 *     - user: this is a permission granted to user sessions/bots, not threads/rooms
		 *     - server: this is a permission granted to server tokens
		 *
		 *     thread permissions are combined with and (you need both permissions)
		 * @enum {string}
		 */
		Permission:
			| "Admin"
			| "BotsAdd"
			| "BotsManage"
			| "EmojiAdd"
			| "EmojiManage"
			| "EmojiUseExternal"
			| "InviteCreate"
			| "InviteManage"
			| "MemberBan"
			| "MemberBanManage"
			| "MemberBridge"
			| "MemberKick"
			| "MemberManage"
			| "MessageAttachments"
			| "MessageCreate"
			| "MessageDelete"
			| "MessageEdit"
			| "MessageEmbeds"
			| "MessageMassMention"
			| "MessageMove"
			| "MessagePin"
			| "ProfileAvatar"
			| "ProfileOverride"
			| "ReactionAdd"
			| "ReactionClear"
			| "RoleApply"
			| "RoleManage"
			| "RoomManage"
			| "ServerAdmin"
			| "ServerMetrics"
			| "ServerOversee"
			| "ServerReports"
			| "TagApply"
			| "TagManage"
			| "ThreadArchive"
			| "ThreadCreateChat"
			| "ThreadCreateDocument"
			| "ThreadCreateEvent"
			| "ThreadCreateForumLinear"
			| "ThreadCreateForumTree"
			| "ThreadCreatePrivate"
			| "ThreadCreatePublic"
			| "ThreadCreateTable"
			| "ThreadCreateVoice"
			| "ThreadDelete"
			| "ThreadEdit"
			| "ThreadForward"
			| "ThreadLock"
			| "ThreadPin"
			| "ThreadPublish"
			| "UserDms"
			| "UserProfile"
			| "UserSessions"
			| "UserStatus"
			| "View"
			| "ViewAuditLog"
			| "VoiceConnect"
			| "VoiceDeafen"
			| "VoiceDisconnect"
			| "VoiceMove"
			| "VoiceMute"
			| "VoicePriority"
			| "VoiceSpeak"
			| "VoiceVideo";
		PermissionOverridable: {
			role_id: components["schemas"]["RoleId"];
			/** @enum {string} */
			type: "Role";
		} | {
			/** @enum {string} */
			type: "User";
			user_id: components["schemas"]["UserId"];
		};
		PermissionOverride: {
			/** @description extra permissions allowed here */
			allow: components["schemas"]["Permission"][];
			/** @description permissions denied here */
			deny: components["schemas"]["Permission"][];
		};
		PermissionOverrideWithTarget:
			& components["schemas"]["PermissionOverridable"]
			& components["schemas"]["PermissionOverride"];
		/** @description the total reaction counts for an emoji */
		ReactionCount: {
			/** Format: int64 */
			count: number;
			emoji: components["schemas"]["Emoji"];
			self: boolean;
		};
		/** @description the total reaction counts for all emoji */
		ReactionCounts: components["schemas"]["ReactionCount"][];
		ReactionListItem: {
			user_id: components["schemas"]["UserId"];
		};
		Relationship: (null | components["schemas"]["Ignore"]) & {
			/** @description whatever you want to write */
			note?: string | null;
			/** @description personal petname for this user */
			petname?: string | null;
			relation?: null | components["schemas"]["RelationshipType"];
		};
		RelationshipPatch: (null | components["schemas"]["Ignore"]) & {
			/** @description whatever you want to write */
			note?: string | null;
			/** @description personal petname for this user */
			petname?: string | null;
			relation?: null | components["schemas"]["RelationshipType"];
		};
		/**
		 * @description a relationship between two users
		 * @enum {string}
		 */
		RelationshipType: "Friend" | "Outgoing" | "Incoming" | "Block";
		/** @description moderation report */
		Report: {
			/** @description where the report is being sent to */
			destination: components["schemas"]["ReportDestination"];
			id: components["schemas"]["ReportId"];
			/** @description user supplied note */
			note?: string | null;
			/** @description built in reason */
			reason: components["schemas"]["ReportReason"];
			/** @description user id of who reported this */
			reporter_id: components["schemas"]["UserId"];
			/** @description what's being reported */
			target: components["schemas"]["ReportTarget"];
		};
		ReportCreate: {
			/** @description where the report is being sent to */
			destination: components["schemas"]["ReportDestination"];
			/** @description user supplied note */
			note?: string | null;
			/** @description built in reason */
			reason: components["schemas"]["ReportReason"];
		};
		/** @enum {string} */
		ReportDestination: "Room" | "Server";
		/** Format: uuid */
		ReportId: string;
		/** @enum {string} */
		ReportReason:
			| "Illegal"
			| "IllegalGoods"
			| "IllegalExtortion"
			| "IllegalPornography"
			| "IllegalHacking"
			| "ExtremeViolence"
			| "PromotesHarm"
			| "UnsolicitedSpam"
			| "Raid"
			| "SpamAbuse"
			| "ScamsFraud"
			| "Malware"
			| "Harassment"
			| "InappropriateProfile"
			| "Impersonation"
			| "BanEvasion"
			| "Underage"
			| "Other";
		ReportTarget: {
			User: {
				target_id: components["schemas"]["UserId"];
			};
		} | {
			Room: {
				target_id: components["schemas"]["RoomId"];
			};
		} | {
			Thread: {
				target_id: components["schemas"]["ThreadId"];
			};
		} | {
			Message: {
				target_id: components["schemas"]["MessageId"];
			};
		} | {
			Media: {
				target_id: components["schemas"]["MediaId"];
			};
		};
		Role: {
			description?: string | null;
			id: components["schemas"]["RoleId"];
			is_default: boolean;
			is_mentionable: boolean;
			is_self_applicable: boolean;
			name: string;
			permissions: components["schemas"]["Permission"][];
			room_id: components["schemas"]["RoomId"];
			version_id: components["schemas"]["RoleVerId"];
		};
		RoleCreate: {
			description?: string | null;
			/** @description if this role is applied by default to all new members */
			is_default?: boolean;
			/** @description if this role can be mentioned by members */
			is_mentionable?: boolean;
			is_self_applicable?: boolean;
			name: string;
			permissions?: components["schemas"]["Permission"][];
		};
		/** Format: uuid */
		RoleId: string;
		RolePatch: {
			description?: string | null;
			is_default?: boolean | null;
			is_mentionable?: boolean | null;
			is_self_applicable?: boolean | null;
			name?: string | null;
			permissions?: components["schemas"]["Permission"][] | null;
		};
		/** Format: uuid */
		RoleVerId: string;
		/** @description A room */
		Room: components["schemas"]["RoomType"] & {
			default_layout: components["schemas"]["ThreadsLayout"];
			default_order: components["schemas"]["ThreadsOrder"];
			description?: string | null;
			/** @description A unique identifier for this room */
			id: components["schemas"]["RoomId"];
			/** @description list of preferred locales, in order of most to least preferred */
			languages: components["schemas"]["Language"][];
			/**
			 * Format: int64
			 * @description number of people in this room
			 */
			member_count: number;
			name: string;
			/**
			 * Format: int64
			 * @description number of people who are online in this room
			 */
			online_count: number;
			system_messages?: null | components["schemas"]["ThreadId"];
			/** @description tags that are applied to this room */
			tags_applied: components["schemas"]["TagId"][];
			/**
			 * @deprecated
			 * @description tags that can be used in threads
			 */
			tags_available: components["schemas"]["TagId"][];
			/**
			 * Format: int64
			 * @description number of active threads
			 */
			thread_count: number;
			/**
			 * Format: uuid
			 * @description A monotonically increasing id that is updated every time this room is modified.
			 */
			version_id: string;
			visibility: components["schemas"]["RoomVisibility"];
		};
		/** @description Data required to create a room */
		RoomCreate: {
			description?: string | null;
			name: string;
		};
		/** Format: uuid */
		RoomId: string;
		RoomMember: components["schemas"]["RoomMembership"] & {
			/** @description When this member's membership last changed (joined, left, was kicked, or banned). */
			membership_updated_at: components["schemas"]["Time"];
			room_id: components["schemas"]["RoomId"];
			user_id: components["schemas"]["UserId"];
		};
		RoomMemberPatch: {
			override_description?: string | null;
			override_name?: string | null;
		};
		RoomMemberPut: {
			override_description?: string | null;
			override_name?: string | null;
		};
		RoomMembership: {
			/** @enum {string} */
			membership: "Join";
			override_description?: string | null;
			override_name?: string | null;
			roles: components["schemas"]["RoleId"][];
		} | {
			/** @enum {string} */
			membership: "Leave";
		} | {
			/** @enum {string} */
			membership: "Ban";
		};
		/** @description An update to a room */
		RoomPatch: {
			description?: string | null;
			name?: string | null;
		};
		RoomType: {
			/** @enum {string} */
			type: "Default";
		} | {
			participants: [
				string,
				string,
			];
			/** @enum {string} */
			type: "Dm";
		} | {
			/** @enum {string} */
			type: "System";
		};
		RoomView: {
			order?: null | components["schemas"]["ThreadsOrder"];
			tags: components["schemas"]["TagId"][];
		};
		/** @description who can view this room */
		RoomVisibility: "Private" | {
			/** @description anyone can view */
			Public: {
				/** @description anyone can search for and find this; otherwise, this is unlisted */
				is_discoverable: boolean;
				/** @description whether anyone can join without an invite; otherwise, this is view only */
				is_free_for_all: boolean;
			};
		};
		/** @enum {string} */
		SearchMessageFeatures:
			| "Attachment"
			| "Image"
			| "Audio"
			| "Video"
			| "Link"
			| "Embed"
			| "Pinned"
			| "Ignored"
			| "Blocked";
		SearchMessageRequest: {
			/** @description The full text search query. Consider this an implementation detail, but I currently use postgres' [`websearch_to_tsquery`](https://www.postgresql.org/docs/17/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES) function. */
			query?: string;
		};
		/** @enum {string} */
		SearchOrder: "Newest" | "Oldest" | "Relevance";
		/** @enum {string} */
		SearchRoomFeatures: "Dm" | "NotDm" | "Muted" | "Public";
		SearchRoomsRequest: {
			/** @description The full text search query. Consider this an implementation detail, but I currently use postgres' [`websearch_to_tsquery`](https://www.postgresql.org/docs/17/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES) function. */
			query?: string;
		};
		/** @enum {string} */
		SearchThreadFeatures: "All" | "Pinned" | "Muted";
		SearchThreadsRequest: {
			/** @description The full text search query. Consider this an implementation detail, but I currently use postgres' [`websearch_to_tsquery`](https://www.postgresql.org/docs/17/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES) function. */
			query?: string;
		};
		ServerVersion: {
			debug: boolean;
			rev: string;
			rustc_channel: string;
			rustc_llvm: string;
			rustc_rev: string;
			rustc_semver: string;
			target: string;
		};
		Session: components["schemas"]["SessionStatus"] & {
			id: components["schemas"]["SessionId"];
			name?: string | null;
		};
		SessionCreate: {
			name?: string | null;
		};
		/** Format: uuid */
		SessionId: string;
		SessionPatch: {
			name?: string | null;
		};
		SessionStatus: {
			/** @enum {string} */
			status: "Unauthorized";
		} | {
			/** @enum {string} */
			status: "Authorized";
			user_id: components["schemas"]["UserId"];
		} | {
			/** @description given ~5 minutes after auth to do stuff? */
			expires_at: components["schemas"]["Time"];
			/** @enum {string} */
			status: "Sudo";
			user_id: components["schemas"]["UserId"];
		};
		SessionToken: string;
		SessionWithToken: components["schemas"]["Session"] & {
			token: components["schemas"]["SessionToken"];
		};
		/** @description the current status of the user */
		Status:
			& components["schemas"]["StatusType"]
			& (null | components["schemas"]["StatusText"]);
		StatusText: {
			clear_at?: null | components["schemas"]["Time"];
			text: string;
		};
		StatusType: {
			/** @enum {string} */
			type: "Offline";
		} | {
			/** @enum {string} */
			type: "Online";
		} | {
			/** @enum {string} */
			type: "Away";
		} | {
			/** @description busy might be set automatically when they look busy
			 *     but it might not be that important
			 *     this explicitly says "do not disturb" */
			dnd: boolean;
			/** @enum {string} */
			type: "Busy";
		} | {
			/** @enum {string} */
			type: "Available";
		};
		/** @description a tag that can be applied to things */
		Tag: {
			color?: null | components["schemas"]["Color"];
			description?: string | null;
			id: components["schemas"]["TagId"];
			/** @description whether this tag is archived. cant be applied to any new threads or appear in pickers but still exists. */
			is_archived: boolean;
			name: string;
			room_id: components["schemas"]["RoomId"];
			version_id: components["schemas"]["TagVerId"];
		};
		TagCreate: {
			color?: null | components["schemas"]["Color"];
			description?: string | null;
			name: string;
			room_id: components["schemas"]["RoomId"];
		};
		/** Format: uuid */
		TagId: string;
		TagPatch: {
			color?: null | components["schemas"]["Color"];
			description?: string | null;
			/** @description whether this tag is archived. cant be applied to any new threads or appear in pickers but still exists. */
			is_archived?: boolean | null;
			name?: string | null;
		};
		/** Format: uuid */
		TagVerId: string;
		/** @description metadata for text */
		Text: {
			language?: null | components["schemas"]["Language"];
		};
		/** @description A thread */
		Thread:
			& components["schemas"]["ThreadPublic"]
			& (null | components["schemas"]["ThreadPrivate"])
			& {
				creator_id: components["schemas"]["UserId"];
				description?: string | null;
				id: components["schemas"]["ThreadId"];
				/** @description if this should be treated as an announcement
				 *     contents will be copied into a new room in all following room */
				is_announcement: boolean;
				/** @description if this thread is locked and cannot be interacted with anymore */
				is_locked: boolean;
				/**
				 * Format: int64
				 * @description number of people in this room
				 *     does not not update with ThreadSync
				 */
				member_count: number;
				name: string;
				/**
				 * Format: int64
				 * @description number of people who are online in this room
				 *     does not not update with ThreadSync
				 */
				online_count: number;
				/** @description emoji reactions to this thread */
				reactions: components["schemas"]["ReactionCounts"];
				room_id: components["schemas"]["RoomId"];
				state: components["schemas"]["ThreadState"];
				state_updated_at: components["schemas"]["Time"];
				/** @description tags that are applied to this thread */
				tags: components["schemas"]["TagId"][];
				/** @description only updates when the thread itself is updated, not the stuff in the thread */
				version_id: components["schemas"]["ThreadVerId"];
				/** @description who can see this thread */
				visibility: components["schemas"]["ThreadVisibility"];
			};
		ThreadCreate: {
			description?: string | null;
			name: string;
			/** @description tags to apply to this thread (overwrite, not append) */
			tags?: components["schemas"]["TagId"][] | null;
			/** @description The type of this thread */
			type?: components["schemas"]["ThreadType"];
		};
		/** Format: uuid */
		ThreadId: string;
		ThreadMember: components["schemas"]["ThreadMembership"] & {
			/** @description When this member's membership last changed (joined, left, was kicked, or banned). */
			membership_updated_at: components["schemas"]["Time"];
			thread_id: components["schemas"]["ThreadId"];
			user_id: components["schemas"]["UserId"];
		};
		ThreadMemberPatch: {
			override_description?: string | null;
			override_name?: string | null;
		};
		ThreadMemberPut: {
			override_description?: string | null;
			override_name?: string | null;
		};
		ThreadMembership: {
			/** @enum {string} */
			membership: "Join";
			override_description?: string | null;
			override_name?: string | null;
		} | {
			/** @enum {string} */
			membership: "Leave";
		} | {
			/** @enum {string} */
			membership: "Ban";
		};
		ThreadPatch: (null | components["schemas"]["ThreadState"]) & {
			description?: string | null;
			name?: string | null;
			/** @description tags to apply to this thread (overwrite, not append) */
			tags?: components["schemas"]["TagId"][] | null;
		};
		/** @description user-specific data for threads */
		ThreadPrivate: components["schemas"]["ThreadTypeChatPrivate"] & {
			/** @enum {string} */
			type: "Chat";
		};
		/** @description type-specific data for threads */
		ThreadPublic: components["schemas"]["ThreadTypeChatPublic"] & {
			/** @enum {string} */
			type: "Chat";
		};
		/** @description lifecycle of a thread */
		ThreadState: {
			/** Format: int32 */
			pin_order: number;
			/** @enum {string} */
			state: "Pinned";
		} | {
			/** @enum {string} */
			state: "Active";
		} | {
			/** @enum {string} */
			state: "Temporary";
		} | {
			/** @enum {string} */
			state: "Archived";
		} | {
			/** @enum {string} */
			state: "Deleted";
		};
		/** @enum {string} */
		ThreadType: "Chat";
		ThreadTypeChatPrivate: {
			is_unread: boolean;
			last_read_id?: null | components["schemas"]["MessageVerId"];
			/** Format: int64 */
			mention_count: number;
			notifications: components["schemas"]["NotifsThread"];
		};
		ThreadTypeChatPublic: {
			last_version_id: components["schemas"]["MessageVerId"];
			/** Format: int64 */
			message_count: number;
		};
		/** Format: uuid */
		ThreadVerId: string;
		/** @description who can view this thread */
		ThreadVisibility: "Room" | {
			/** @description anyone can view */
			Public: {
				/** @description anyone can search for and find this; otherwise, this is unlisted */
				is_discoverable: boolean;
				/** @description whether anyone can join without an invite; otherwise, this is view only */
				is_free_for_all: boolean;
			};
		} | {
			/** @description only visible to existing thread members */
			Private: Record<string, never>;
		};
		/**
		 * @description how to display the room's thread list
		 * @enum {string}
		 */
		ThreadsLayout: "Card" | "Compact" | "Gallery" | "Masonry";
		/**
		 * @description how to sort the room's thread list
		 * @enum {string}
		 */
		ThreadsOrder: "Time";
		/**
		 * Format: date-time
		 * @description A date, time, and timezone. Serialized to rfc3339.
		 */
		Time: string;
		/** @description metadata for captions/subtitles */
		TimedText: {
			/** Format: int64 */
			duration: number;
			language?: null | components["schemas"]["Language"];
		};
		TotpRecoveryCode: {
			code: string;
			used?: null | components["schemas"]["TotpRecoveryCodeUsed"];
		};
		/** @description information about who used this code */
		TotpRecoveryCodeUsed: {
			used_at: components["schemas"]["Time"];
			used_by?: null | components["schemas"]["SessionId"];
		};
		TotpRecoveryCodes: {
			items: components["schemas"]["TotpRecoveryCode"][];
		};
		TotpState: {
			is_valid: boolean;
		};
		TotpStateWithSecret: components["schemas"]["TotpState"] & {
			secret: string;
		};
		TotpVerificationRequest: {
			code: string;
		};
		/** @description Where this track came from. */
		TrackSource: {
			/** @enum {string} */
			source: "Uploaded";
		} | {
			/** @enum {string} */
			source: "Downloaded";
			/** Format: uri */
			source_url: string;
		} | {
			/** @enum {string} */
			source: "Extracted";
		} | {
			/** @enum {string} */
			source: "Generated";
		};
		UrlEmbed: {
			author_avatar?: null | components["schemas"]["Media"];
			author_name?: string | null;
			/** Format: uri */
			author_url?: string | null;
			/**
			 * Format: uri
			 * @description the final resolved url, after redirects and canonicalization. If None, its the same as `url`.
			 */
			canonical_url?: string | null;
			color?: null | components["schemas"]["Color"];
			description?: string | null;
			id: components["schemas"]["UrlEmbedId"];
			media?: null | components["schemas"]["Media"];
			/** @description if `media` should be displayed as a small thumbnail or as a full size */
			media_is_thumbnail: boolean;
			site_avatar?: null | components["schemas"]["Media"];
			/** @description the name of the website */
			site_name?: string | null;
			title?: string | null;
			/**
			 * Format: uri
			 * @description the url this embed was requested for
			 */
			url: string;
		};
		/** Format: uuid */
		UrlEmbedId: string;
		UrlEmbedRequest: {
			/** Format: uri */
			url: string;
		};
		User: components["schemas"]["UserType"] & {
			avatar?: null | components["schemas"]["MediaId"];
			description?: string | null;
			id: components["schemas"]["UserId"];
			name: string;
			state: components["schemas"]["UserState"];
			state_updated_at: components["schemas"]["Time"];
			status: components["schemas"]["Status"];
			version_id: components["schemas"]["UserVerId"];
		};
		/** @description configuration for a user */
		UserConfig: {
			/** @description config specific to frontend */
			frontend: {
				[key: string]: unknown;
			};
			/** @description global notification config */
			notifs: components["schemas"]["NotifsGlobal"];
		};
		UserCreate: components["schemas"]["UserType"] & {
			description?: string | null;
			name: string;
		};
		/** Format: uuid */
		UserId: string;
		UserIdReq: null | components["schemas"]["UserId"];
		/** @enum {string} */
		UserListFilter: "Mutual" | "Friends" | "Dms" | "Puppet" | "Bot";
		UserPatch: {
			avatar?: null | components["schemas"]["MediaId"];
			description?: string | null;
			name?: string | null;
		};
		/** @enum {string} */
		UserState: "Active" | "Suspended" | "Deleted";
		UserType:
			| {
				/** @enum {string} */
				type: "Default";
			}
			| (components["schemas"]["BotOwner"] & {
				/** @description enables managing Puppet users */
				is_bridge: boolean;
				/** @description who can use the bot */
				visibility: components["schemas"]["BotVisibility"];
			} & {
				/** @enum {string} */
				type: "Bot";
			})
			| {
				alias_id?: null | components["schemas"]["UserId"];
				/** @description an opaque identifier from the other platform */
				external_id?: string;
				/** @description what platform this puppet is connected to */
				external_platform: components["schemas"]["ExternalPlatform"];
				/**
				 * Format: uri
				 * @description a url on the other platform that this account can be reached at
				 */
				external_url?: string | null;
				/** @description the user who created this puppet */
				owner_id: components["schemas"]["UserId"];
				/** @enum {string} */
				type: "Puppet";
			}
			| {
				/** @enum {string} */
				type: "System";
			};
		/** Format: uuid */
		UserVerId: string;
		/** @description metadata for videos */
		Video: {
			codec: string;
			/** Format: int64 */
			duration: number;
			/** Format: int64 */
			height: number;
			language?: null | components["schemas"]["Language"];
			/** Format: int64 */
			width: number;
		};
	};
	responses: never;
	parameters: never;
	requestBodies: never;
	headers: never;
	pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
	auth_status: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["AuthStatus"];
				};
			};
		};
	};
	auth_captcha_init: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["CaptchaChallenge"];
				};
			};
		};
	};
	auth_captcha_submit: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["CaptchaResponse"];
			};
		};
		responses: {
			/** @description captcha ok */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			/** @description captcha failure */
			401: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	auth_email_exec: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Email address */
				addr: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			202: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	auth_email_reset: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Email address */
				addr: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			202: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	auth_oauth_get: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description oauth provider */
				provider: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	auth_oauth_init: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description oauth provider */
				provider: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description ready */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["OauthInitResponse"];
				};
			};
		};
	};
	auth_oauth_delete: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description oauth provider */
				provider: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	auth_oauth_logout: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description oauth provider */
				provider: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	auth_oauth_redirect: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description oauth provider */
				provider: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success; responds with html + javascript */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	auth_password_set: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["PasswordSet"];
			};
		};
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	auth_password_exec: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["PasswordExec"];
			};
		};
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	auth_password_delete: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	auth_totp_exec: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["TotpVerificationRequest"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["TotpState"];
				};
			};
		};
	};
	auth_totp_delete: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	auth_totp_init: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["TotpStateWithSecret"];
				};
			};
		};
	};
	auth_totp_recovery_get: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["TotpRecoveryCodes"];
				};
			};
		};
	};
	auth_totp_recovery_rotate: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["TotpRecoveryCodes"];
				};
			};
		};
	};
	debug_embed_url: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["UrlEmbedRequest"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["UrlEmbed"];
				};
			};
		};
	};
	debug_version: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ServerVersion"];
				};
			};
		};
	};
	emoji_create: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["EmojiCustomCreate"];
			};
		};
		responses: {
			/** @description new emoji created */
			201: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["EmojiCustom"];
				};
			};
		};
	};
	emoji_get: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Emoji id */
				emoji_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["EmojiCustom"];
				};
			};
		};
	};
	emoji_delete: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Emoji id */
				emoji_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	emoji_update: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Emoji id */
				emoji_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["EmojiCustomPatch"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["EmojiCustom"];
				};
			};
			/** @description not modified */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	inbox_query: {
		parameters: {
			query: {
				from?: string;
				to?: string;
				dir?: "b" | "f";
				limit?: number;
				include: components["schemas"]["InboxFilters"];
				/** @description only include notifications from this room */
				room_id?: components["schemas"]["RoomId"][];
				/** @description only include notifications from this thread */
				thread_id?: components["schemas"]["ThreadId"][];
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json":
						components["schemas"]["PaginationResponse_Notification"];
				};
			};
		};
	};
	inbox_patch: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["InboxPatch"];
			};
		};
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	invite_resolve: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description The code identifying this invite */
				invite_code: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success with metadata */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["InviteWithMetadata"];
				};
			};
		};
	};
	invite_use: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description The code identifying this invite */
				invite_code: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	invite_delete: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description The code identifying this invite */
				invite_code: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	invite_patch: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description The code identifying this invite */
				invite_code: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["InvitePatch"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Invite"];
				};
			};
			/** @description not modified */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	media_create: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["MediaCreate"];
			};
		};
		responses: {
			/** @description Create media success */
			201: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["MediaCreated"];
				};
			};
		};
	};
	media_get: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Media id */
				media_id: components["schemas"]["MediaId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Media"];
				};
			};
		};
	};
	media_delete: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Media id */
				media_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description no content */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			/** @description media is linked to another resource (ie. a message) */
			409: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	media_patch: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Media id */
				media_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["MediaPatch"];
			};
		};
		responses: {
			/** @description Success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Media"];
				};
			};
			/** @description Not modified */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	media_done: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Media id */
				media_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Media"];
				};
			};
		};
	};
	report_media: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description media id */
				media_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["ReportCreate"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Report"];
				};
			};
		};
	};
	room_list: {
		parameters: {
			query?: {
				from?: string;
				to?: string;
				dir?: "b" | "f";
				limit?: number;
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Paginate room success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["PaginationResponse_Room"];
				};
			};
		};
	};
	room_create: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["RoomCreate"];
			};
		};
		responses: never;
	};
	room_get: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Room id */
				room_id: components["schemas"]["RoomId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Get room success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Room"];
				};
			};
			/** @description Not modified */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	room_edit: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Room id */
				room_id: components["schemas"]["RoomId"];
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["RoomPatch"];
			};
		};
		responses: {
			/** @description edit success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			/** @description no change */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	room_ack: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Room id */
				room_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	invite_room_list: {
		parameters: {
			query?: {
				from?: string;
				to?: string;
				dir?: "b" | "f";
				limit?: number;
			};
			header?: never;
			path: {
				/** @description Room id */
				room_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json":
						components["schemas"]["PaginationResponse_Invite"];
				};
			};
		};
	};
	invite_room_create: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Room id */
				room_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["InviteCreate"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Invite"];
				};
			};
		};
	};
	room_audit_logs: {
		parameters: {
			query?: {
				from?: string;
				to?: string;
				dir?: "b" | "f";
				limit?: number;
			};
			header?: never;
			path: {
				/** @description Room id */
				room_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description fetch audit logs success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json":
						components["schemas"]["PaginationResponse_AuditLog"];
				};
			};
		};
	};
	room_member_list: {
		parameters: {
			query?: {
				from?: string;
				to?: string;
				dir?: "b" | "f";
				limit?: number;
			};
			header?: never;
			path: {
				/** @description Room id */
				room_id: components["schemas"]["RoomId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json":
						components["schemas"]["PaginationResponse_RoomMember"];
				};
			};
		};
	};
	room_member_get: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Room id */
				room_id: components["schemas"]["RoomId"];
				/** @description User id */
				user_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["RoomMember"];
				};
			};
		};
	};
	room_member_add: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Room id */
				room_id: components["schemas"]["RoomId"];
				/** @description User id */
				user_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["RoomMemberPut"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["RoomMember"];
				};
			};
			/** @description not modified */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	room_member_delete: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Room id */
				room_id: components["schemas"]["RoomId"];
				/** @description User id */
				user_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	room_member_update: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Room id */
				room_id: components["schemas"]["RoomId"];
				/** @description User id */
				user_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["RoomMemberPatch"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["RoomMember"];
				};
			};
			/** @description not modified */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	notification_edit_room: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Room id */
				room_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["NotifsThread"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["NotifsRoom"];
				};
			};
		};
	};
	report_room: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Room id */
				room_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["ReportCreate"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Report"];
				};
			};
		};
	};
	role_list: {
		parameters: {
			query?: {
				from?: string;
				to?: string;
				dir?: "b" | "f";
				limit?: number;
			};
			header?: never;
			path: {
				/** @description Room id */
				room_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["PaginationResponse_Role"];
				};
			};
		};
	};
	role_create: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Room id */
				room_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["RoleCreate"];
			};
		};
		responses: {
			/** @description success */
			201: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Role"];
				};
			};
		};
	};
	role_get: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Room id */
				room_id: components["schemas"]["RoomId"];
				/** @description Role id */
				role_id: components["schemas"]["RoleId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Role"];
				};
			};
		};
	};
	role_delete: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Room id */
				room_id: components["schemas"]["RoomId"];
				/** @description Role id */
				role_id: components["schemas"]["RoleId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	role_update: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Room id */
				room_id: components["schemas"]["RoomId"];
				/** @description Role id */
				role_id: components["schemas"]["RoleId"];
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["RolePatch"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Role"];
				};
			};
			/** @description success */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	role_member_list: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Room id */
				room_id: components["schemas"]["RoomId"];
				/** @description Role id */
				role_id: components["schemas"]["RoleId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json":
						components["schemas"]["PaginationResponse_RoomMember"];
				};
			};
		};
	};
	role_member_add: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Room id */
				room_id: components["schemas"]["RoomId"];
				/** @description Role id */
				role_id: components["schemas"]["RoleId"];
				/** @description User id */
				user_id: components["schemas"]["UserId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["RoomMember"];
				};
			};
		};
	};
	role_member_remove: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Room id */
				room_id: components["schemas"]["RoomId"];
				/** @description Role id */
				role_id: components["schemas"]["RoleId"];
				/** @description User id */
				user_id: components["schemas"]["UserId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["RoomMember"];
				};
			};
		};
	};
	tag_list_room: {
		parameters: {
			query?: {
				from?: string;
				to?: string;
				dir?: "b" | "f";
				limit?: number;
			};
			header?: never;
			path: {
				/** @description Room id */
				room_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["PaginationResponse_Tag"];
				};
			};
		};
	};
	tag_room_apply: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Room id */
				room_id: components["schemas"]["RoomId"];
				/** @description Tag id */
				tag_id: components["schemas"]["TagId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			/** @description not modified */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	tag_room_unapply: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Room id */
				room_id: components["schemas"]["RoomId"];
				/** @description Tag id */
				tag_id: components["schemas"]["TagId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			/** @description not modified */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	permission_tag_override: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Room id */
				room_id: string;
				/** @description Tag id */
				tag_id: string;
				/** @description Role or user id */
				overwrite_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["PermissionOverride"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json":
						components["schemas"]["PermissionOverrideWithTarget"];
				};
			};
		};
	};
	permission_tag_delete: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Room id */
				room_id: string;
				/** @description Tag id */
				tag_id: string;
				/** @description Role or user id */
				overwrite_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	thread_list: {
		parameters: {
			query?: {
				from?: string;
				to?: string;
				dir?: "b" | "f";
				limit?: number;
			};
			header?: never;
			path: {
				/** @description Room id */
				room_id: components["schemas"]["RoomId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description List room threads success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json":
						components["schemas"]["PaginationResponse_Thread"];
				};
			};
		};
	};
	thread_create: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Room id */
				room_id: components["schemas"]["RoomId"];
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["ThreadCreate"];
			};
		};
		responses: {
			/** @description Create thread success */
			201: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Thread"];
				};
			};
		};
	};
	report_message: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description room id */
				room_id: string;
				/** @description thread id */
				thread_id: string;
				/** @description message id */
				message_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["ReportCreate"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Report"];
				};
			};
		};
	};
	report_thread: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description room id */
				room_id: string;
				/** @description thread id */
				thread_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["ReportCreate"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Report"];
				};
			};
		};
	};
	emoji_list_room: {
		parameters: {
			query?: {
				from?: string;
				to?: string;
				dir?: "b" | "f";
				limit?: number;
			};
			header?: never;
			path: {
				/** @description Room id */
				room_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json":
						components["schemas"]["PaginationResponse_EmojiCustom"];
				};
			};
		};
	};
	search_messages: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["SearchMessageRequest"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json":
						components["schemas"]["PaginationResponse_Message"];
				};
			};
		};
	};
	search_rooms: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["SearchRoomsRequest"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["PaginationResponse_Room"];
				};
			};
		};
	};
	search_threads: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["SearchThreadsRequest"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json":
						components["schemas"]["PaginationResponse_Thread"];
				};
			};
		};
	};
	session_list: {
		parameters: {
			query?: {
				from?: string;
				to?: string;
				dir?: "b" | "f";
				limit?: number;
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description List session success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json":
						components["schemas"]["PaginationResponse_Session"];
				};
			};
		};
	};
	session_create: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["SessionCreate"];
			};
		};
		responses: {
			/** @description success */
			201: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["SessionWithToken"];
				};
			};
		};
	};
	session_get: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Session id */
				session_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Session"];
				};
			};
		};
	};
	session_delete: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Session id */
				session_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	session_update: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Session id */
				session_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["SessionPatch"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Session"];
				};
			};
			/** @description not modified */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Session"];
				};
			};
		};
	};
	tag_list_user: {
		parameters: {
			query?: {
				from?: string;
				to?: string;
				dir?: "b" | "f";
				limit?: number;
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["PaginationResponse_Tag"];
				};
			};
		};
	};
	tag_create: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["TagCreate"];
			};
		};
		responses: {
			/** @description success */
			201: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Tag"];
				};
			};
		};
	};
	tag_get: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Tag id */
				tag_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Tag"];
				};
			};
		};
	};
	tag_delete: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Tag id */
				tag_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	tag_patch: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Tag id */
				tag_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["TagPatch"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Tag"];
				};
			};
			/** @description not modified */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	tag_tag_apply: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Target tag id */
				target_id: string;
				/** @description Tag id of tag to tag tag with */
				with_id: string;
				tag_id: components["schemas"]["TagId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			/** @description not modified */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	tag_tag_unapply: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Target tag id */
				target_id: string;
				/** @description Tag id of tag to tag tag with */
				with_id: string;
				tag_id: components["schemas"]["TagId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			/** @description not modified */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	thread_get: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Get thread success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Thread"];
				};
			};
		};
	};
	thread_delete: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	thread_update: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["ThreadPatch"];
			};
		};
		responses: {
			/** @description edit message success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Thread"];
				};
			};
			/** @description no change */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Thread"];
				};
			};
		};
	};
	thread_ack: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["AckReq"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	thread_activate: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Thread"];
				};
			};
			/** @description didn't change anything */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Thread"];
				};
			};
		};
	};
	thread_archive: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Thread"];
				};
			};
			/** @description didn't change anything */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Thread"];
				};
			};
		};
	};
	message_context: {
		parameters: {
			query?: {
				to_start?: null | components["schemas"]["MessageId"];
				to_end?: null | components["schemas"]["MessageId"];
				limit?: number | null;
			};
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
				/** @description Message id */
				message_id: components["schemas"]["MessageId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description List thread messages success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ContextResponse"];
				};
			};
		};
	};
	thread_member_list: {
		parameters: {
			query?: {
				from?: string;
				to?: string;
				dir?: "b" | "f";
				limit?: number;
			};
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json":
						components["schemas"]["PaginationResponse_ThreadMember"];
				};
			};
		};
	};
	thread_member_get: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
				/** @description User id */
				user_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ThreadMember"];
				};
			};
		};
	};
	thread_member_add: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
				/** @description User id */
				user_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["ThreadMemberPut"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ThreadMember"];
				};
			};
			/** @description not modified */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	thread_member_delete: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
				/** @description User id */
				user_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	thread_member_update: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
				/** @description User id */
				user_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["ThreadMemberPatch"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ThreadMember"];
				};
			};
			/** @description not modified */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	message_list: {
		parameters: {
			query?: {
				from?: string;
				to?: string;
				dir?: "b" | "f";
				limit?: number;
			};
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description List thread messages success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json":
						components["schemas"]["PaginationResponse_Message"];
				};
			};
		};
	};
	message_create: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["MessageCreate"];
			};
		};
		responses: {
			/** @description Create message success */
			201: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Message"];
				};
			};
		};
	};
	message_get: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
				/** @description Message id */
				message_id: components["schemas"]["MessageId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description List thread messages success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Message"];
				};
			};
		};
	};
	message_delete: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
				/** @description Message id */
				message_id: components["schemas"]["MessageId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description delete message success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	message_edit: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
				/** @description Message id */
				message_id: components["schemas"]["MessageId"];
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["MessagePatch"];
			};
		};
		responses: {
			/** @description edit message success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Message"];
				};
			};
			/** @description no change */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	reaction_message_purge: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
				/** @description Message id */
				message_id: components["schemas"]["MessageId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	reaction_message_list: {
		parameters: {
			query?: {
				from?: string;
				to?: string;
				dir?: "b" | "f";
				limit?: number;
			};
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
				/** @description Message id */
				message_id: components["schemas"]["MessageId"];
				/** @description Reaction key */
				key: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json":
						components["schemas"]["PaginationResponse_ReactionListItem"];
				};
			};
		};
	};
	reaction_message_add: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
				/** @description Message id */
				message_id: components["schemas"]["MessageId"];
				/** @description Reaction key */
				key: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description already exists */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			/** @description new reaction created */
			201: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	reaction_message_remove: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
				/** @description Message id */
				message_id: components["schemas"]["MessageId"];
				/** @description Reaction key */
				key: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	message_version_list: {
		parameters: {
			query?: {
				from?: string;
				to?: string;
				dir?: "b" | "f";
				limit?: number;
			};
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
				/** @description Message id */
				message_id: components["schemas"]["MessageId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json":
						components["schemas"]["PaginationResponse_Message"];
				};
			};
		};
	};
	message_version_get: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
				/** @description Message id */
				message_id: components["schemas"]["MessageId"];
				/** @description Version id */
				version_id: components["schemas"]["MessageVerId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Message"];
				};
			};
		};
	};
	message_version_delete: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
				/** @description Message id */
				message_id: components["schemas"]["MessageId"];
				/** @description Version id */
				version_id: components["schemas"]["MessageVerId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description delete message success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	message_delete_bulk: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Message id */
				message_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["MessageDeleteBulk"];
			};
		};
		responses: {
			/** @description bulk delete success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	notification_edit_thread: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["NotifsThread"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["NotifsThread"];
				};
			};
		};
	};
	permission_thread_override: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: string;
				/** @description Role or user id */
				overwrite_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["PermissionOverride"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json":
						components["schemas"]["PermissionOverrideWithTarget"];
				};
			};
		};
	};
	permission_thread_delete: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: string;
				/** @description Role or user id */
				overwrite_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	thread_pin: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Thread"];
				};
			};
			/** @description didn't change anything */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Thread"];
				};
			};
		};
	};
	reaction_thread_purge: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	reaction_thread_list: {
		parameters: {
			query?: {
				from?: string;
				to?: string;
				dir?: "b" | "f";
				limit?: number;
			};
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
				/** @description Reaction key */
				key: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json":
						components["schemas"]["PaginationResponse_ReactionListItem"];
				};
			};
		};
	};
	reaction_thread_add: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
				/** @description Reaction key */
				key: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description new reaction created */
			201: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			/** @description already exists */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	reaction_thread_remove: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
				/** @description Reaction key */
				key: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	message_replies: {
		parameters: {
			query: {
				q: components["schemas"]["PaginationQuery_MessageId"];
				/** @description how deeply to fetch replies */
				depth?: number;
			};
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
				/** @description Message id */
				message_id: components["schemas"]["MessageId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description List thread messages success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json":
						components["schemas"]["PaginationResponse_Message"];
				};
			};
		};
	};
	tag_thread_apply: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
				/** @description Tag id */
				tag_id: components["schemas"]["TagId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			/** @description not modified */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	tag_thread_unapply: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: components["schemas"]["ThreadId"];
				/** @description Tag id */
				tag_id: components["schemas"]["TagId"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			/** @description not modified */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	thread_typing: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Thread id */
				thread_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	user_list: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				include: components["schemas"]["UserListFilter"][];
				from: string;
				to: string;
				dir: "b" | "f";
				limit: number;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["PaginationResponse_User"];
				};
			};
		};
	};
	user_create: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["UserCreate"];
			};
		};
		responses: {
			/** @description success */
			201: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["User"];
				};
			};
		};
	};
	dm_get: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Target user's id */
				target_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	dm_init: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Target user's id */
				target_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description already exists */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			/** @description new dm created */
			201: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	emoji_list_user: {
		parameters: {
			query?: {
				from?: string;
				to?: string;
				dir?: "b" | "f";
				limit?: number;
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json":
						components["schemas"]["PaginationResponse_EmojiCustom"];
				};
			};
		};
	};
	relationship_get: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Target user's id */
				target_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Relationship"];
				};
			};
		};
	};
	relationship_reset: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Target user's id */
				target_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	relationship_update: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Target user's id */
				target_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["RelationshipPatch"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Relationship"];
				};
			};
			/** @description not modified */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	user_get: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description User id */
				user_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["User"];
				};
			};
		};
	};
	user_delete: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description User id */
				user_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	user_update: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description User id */
				user_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["UserPatch"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["User"];
				};
			};
			/** @description not modified */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	user_config_get: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description User id */
				user_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["UserConfig"];
				};
			};
		};
	};
	user_config_set: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description User id */
				user_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["UserConfig"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["UserConfig"];
				};
			};
		};
	};
	email_list: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description User id */
				user_id: components["schemas"]["UserIdReq"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["EmailInfo"][];
				};
			};
		};
	};
	email_get: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description User id */
				user_id: components["schemas"]["UserIdReq"];
				/** @description email address */
				addr: components["schemas"]["EmailAddr"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["EmailInfo"];
				};
			};
			/** @description doesn't exist */
			404: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	email_add: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description User id */
				user_id: components["schemas"]["UserIdReq"];
				/** @description email address */
				addr: components["schemas"]["EmailAddr"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description already exists */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			/** @description success */
			201: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	email_delete: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description User id */
				user_id: components["schemas"]["UserIdReq"];
				/** @description email address */
				addr: components["schemas"]["EmailAddr"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	email_resent_verification: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description User id */
				user_id: components["schemas"]["UserIdReq"];
				/** @description email address */
				addr: components["schemas"]["EmailAddr"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			204: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
		};
	};
	invite_user_create: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description User id */
				user_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["InviteCreate"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Invite"];
				};
			};
		};
	};
	relationship_list: {
		parameters: {
			query?: {
				from?: string;
				to?: string;
				dir?: "b" | "f";
				limit?: number;
			};
			header?: never;
			path: {
				/** @description User id to list relationships from */
				user_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json":
						components["schemas"]["PaginationResponse_Relationship"];
				};
			};
		};
	};
	report_user: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description user id */
				user_id: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["ReportCreate"];
			};
		};
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["Report"];
				};
			};
		};
	};
	mutual_room_list: {
		parameters: {
			query?: {
				from?: string;
				to?: string;
				dir?: "b" | "f";
				limit?: number;
			};
			header?: never;
			path: {
				/** @description user id */
				user_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["PaginationResponse_Room"];
				};
			};
		};
	};
	invite_user_list: {
		parameters: {
			query?: {
				from?: string;
				to?: string;
				dir?: "b" | "f";
				limit?: number;
			};
			header?: never;
			path: {
				/** @description User id */
				user_id: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description success */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json":
						components["schemas"]["PaginationResponse_Invite"];
				};
			};
		};
	};
}
